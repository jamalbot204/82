
import React, { memo, useState, useEffect, useRef, Suspense, useMemo } from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import rehypeRaw from 'rehype-raw';
import Mark from 'mark.js/dist/mark.es6.js';
import { ChatMessage } from '../../../types.ts';
import { useEditorUI } from '../../../store/ui/useEditorUI.ts';
import { useGlobalUiStore } from '../../../store/useGlobalUiStore.ts';
import { ClipboardIcon, CheckIcon, SitemapIcon, ChevronDownIcon, ChevronUpIcon } from '../../common/Icons.tsx';
import { MESSAGE_CONTENT_SNIPPET_THRESHOLD } from '../../../constants.ts';
import { preprocessMessageContent } from '../../../services/utils.ts';

const CodeBlockHighlighter = React.lazy(() => import('../../common/CodeBlockHighlighter.tsx'));

interface MessageContentProps {
  message: ChatMessage;
  displayContent: string;
  highlightTerm?: string;
  isContentExpanded: boolean;
  onToggleExpansion: (messageId: string, type: 'content') => void;
}

// --- CUSTOM TEXT PROCESSOR ---
// [REMOVED] Recursive React Node processing for quotes.
// This is now handled by Regex in services/utils.ts for better performance.

const markdownRenderers = {
    code({ node, inline, className, children, ...props }: any) {
        const [isCodeCopied, setIsCodeCopied] = useState(false);
        const codeString = String(children).replace(/\n$/, '');
        const { openMermaidModal } = useEditorUI.getState();
        const { message } = props.message_obj; 

        const handleCopyCode = () => {
            navigator.clipboard.writeText(codeString).then(() => {
                setIsCodeCopied(true);
                setTimeout(() => setIsCodeCopied(false), 2000);
            }).catch(err => {
                console.error('Failed to copy code: ', err);
                alert('Failed to copy code.');
            });
        };
        
        const match = /language-(\w+)/.exec(className || '');
        const lang = match ? match[1] : 'text';
        const isMermaid = lang.toLowerCase() === 'mermaid';

        return !inline && match ? (
            <div className="relative group/codeblock my-2 rounded-md shadow border border-aurora-border bg-aurora-codeBg">
                <div className="sticky top-0 z-10 flex justify-between items-center px-4 py-1.5 bg-black/40 backdrop-blur-md rounded-t-md border-b border-white/5">
                  <span className="text-xs text-gray-300 font-mono">{lang}</span>
                  <div className="flex items-center space-x-2">
                    {isMermaid && (
                      <button
                        onClick={() => openMermaidModal({ code: codeString, messageId: message.id, fullContent: message.content })}
                        title="Render Diagram"
                        aria-label="Render Mermaid diagram"
                        className="p-1.5 bg-black/30 text-gray-300 hover:text-white rounded-md transition-all duration-150 opacity-0 group-hover/codeblock:opacity-100 focus:opacity-100 hover:shadow-[0_0_8px_1px_rgba(34,197,94,0.6)]"
                      >
                        <SitemapIcon className="w-4 h-4 text-green-400" />
                      </button>
                    )}
                    <button onClick={handleCopyCode} title={isCodeCopied ? "Copied!" : "Copy code"} aria-label={isCodeCopied ? "Copied code to clipboard" : "Copy code to clipboard"} className="p-1.5 bg-black/30 text-gray-300 hover:text-white rounded-md transition-all duration-150 opacity-0 group-hover/codeblock:opacity-100 focus:opacity-100 hover:shadow-[0_0_8px_1px_rgba(255,255,255,0.2)]">
                      {isCodeCopied ? <CheckIcon className="w-4 h-4 text-green-400" /> : <ClipboardIcon className="w-4 h-4" />}
                    </button>
                  </div>
                </div>
                <div className="overflow-hidden rounded-b-md">
                    <Suspense fallback={<div className="p-4 text-xs text-gray-500 font-mono">Loading code view...</div>}>
                        <CodeBlockHighlighter language={lang} codeString={codeString} />
                    </Suspense>
                </div>
            </div>
        ) : (
            // This styling ensures the "Purple Glowing" effect for inline code/tags
            <code className="bg-aurora-surface text-aurora-accentSecondary rounded font-mono border border-aurora-border px-1 py-0.5 break-all whitespace-pre-wrap" {...props}>{children}</code>
        );
    },
    a(props: any) { return <a target="_blank" rel="noopener noreferrer" {...props} />; }
};

const MessageContent: React.FC<MessageContentProps> = memo(({ message, displayContent, highlightTerm, isContentExpanded, onToggleExpansion }) => {
    const markdownContentRef = useRef<HTMLDivElement>(null);
    const chatFontSizeLevel = useGlobalUiStore(state => state.chatFontSizeLevel);
    
    // Process content to handle custom headers and tags (but NOT quotes anymore)
    const processedContent = useMemo(() => {
        return preprocessMessageContent(displayContent);
    }, [displayContent]);

    const isLongTextContent = processedContent.trim().length > MESSAGE_CONTENT_SNIPPET_THRESHOLD;
    const contentToRender = (isLongTextContent && !isContentExpanded) ? processedContent.trim().substring(0, MESSAGE_CONTENT_SNIPPET_THRESHOLD) + "..." : processedContent;

    useEffect(() => {
        if (message.isGithubContextMessage) return; 
        if (!highlightTerm || highlightTerm.trim() === "") return;

        if (markdownContentRef.current) {
          const instance = new Mark(markdownContentRef.current);
          instance.unmark({ done: () => { instance.mark(highlightTerm, { element: "mark", className: "highlighted-text", exclude: ["pre *", "code *", "pre", "code"], separateWordSearch: false, accuracy: "partially", wildcards: "disabled" }); } });
        }
    }, [highlightTerm, contentToRender, isContentExpanded, message.isGithubContextMessage]);

    const getFontSizeClass = (level: number) => {
        switch (level) {
            case 0: return 'text-xs';
            case 1: return 'text-sm';
            case 2: return 'text-base';
            case 3: return 'text-lg';
            case 4: return 'text-xl';
            default: return 'text-sm';
        }
    };

    const fontSizeClass = getFontSizeClass(chatFontSizeLevel);

    if (!contentToRender.trim()) return null;

    return (
        <>
            <div id={`message-content-${message.id}`} ref={markdownContentRef} className={`${fontSizeClass} markdown-content break-words transition-all duration-200`}>
                <ReactMarkdown 
                    remarkPlugins={[remarkGfm]} 
                    rehypePlugins={[rehypeRaw]} 
                    components={{...markdownRenderers, code: (props) => markdownRenderers.code({...props, message_obj: {message}})}}
                >
                    {contentToRender}
                </ReactMarkdown>
            </div>
            {(isLongTextContent && !isContentExpanded) && (
                <div id={`message-content-export-${message.id}`} style={{ display: 'none' }}>
                    <ReactMarkdown remarkPlugins={[remarkGfm]} rehypePlugins={[rehypeRaw]} components={{...markdownRenderers, code: (props) => markdownRenderers.code({...props, message_obj: {message}})}}>{processedContent}</ReactMarkdown>
                </div>
            )}
            {isLongTextContent && (
                <button onClick={() => onToggleExpansion(message.id, 'content')} className="text-blue-300 hover:text-blue-200 text-xs mt-1.5 focus:outline-none flex items-center transition-all hover:drop-shadow-[0_0_3px_rgba(147,197,253,0.8)]" aria-expanded={isContentExpanded}>
                    {isContentExpanded ? "Show less" : "Show more"}
                    {isContentExpanded ? (<ChevronUpIcon className="w-3.5 h-3.5 ml-1" />) : (<ChevronDownIcon className="w-3.5 h-3.5 ml-1" />)}
                </button>
            )}
        </>
    );
});

export default MessageContent;
